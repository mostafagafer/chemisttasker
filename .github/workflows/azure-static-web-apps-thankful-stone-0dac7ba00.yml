name: Azure Static Web Apps CI/CD

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]

jobs:
  build_and_deploy_job:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    runs-on: ubuntu-latest
    name: Build and Deploy Job
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          lfs: false

      # Use Node 20 for your repo tooling (react-router v7 wants >= 20)
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: |
            shared-core/package-lock.json
            frontend_web/package-lock.json

      # -------------------------
      # shared-core: build + pack tgz
      # -------------------------
      - name: Install shared-core dependencies
        working-directory: shared-core
        run: npm ci --no-audit --no-fund

      - name: Build shared-core
        working-directory: shared-core
        run: npm run build

      - name: Remove old shared-core tarballs
        working-directory: shared-core
        run: rm -f *.tgz

      - name: Pack shared-core tarball
        working-directory: shared-core
        run: npm pack

      # -------------------------
      # frontend_web: patch lockfile integrity to match freshly packed tgz
      # (prevents EINTEGRITY when Azure/Oryx runs npm install during SWA build)
      # -------------------------
      - name: Patch shared-core integrity in frontend_web lockfile
        working-directory: frontend_web
        run: |
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const crypto = require('crypto');

          const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const dep = pkg.dependencies && pkg.dependencies['@chemisttasker/shared-core'];
          if (!dep || !dep.startsWith('file:')) {
            throw new Error('Expected dependencies["@chemisttasker/shared-core"] to be a file:... path');
          }

          const rel = dep.replace(/^file:/, '');
          const tgzPath = path.resolve(process.cwd(), rel);

          if (!fs.existsSync(tgzPath)) {
            throw new Error(`shared-core tarball not found at: ${tgzPath}`);
          }

          const buf = fs.readFileSync(tgzPath);
          const integrity = 'sha512-' + crypto.createHash('sha512').update(buf).digest('base64');

          const lockPath = path.resolve(process.cwd(), 'package-lock.json');
          const lock = JSON.parse(fs.readFileSync(lockPath, 'utf8'));

          const pkgKey = 'node_modules/@chemisttasker/shared-core';
          if (!lock.packages || !lock.packages[pkgKey]) {
            throw new Error(`package-lock.json missing packages["${pkgKey}"] entry`);
          }

          lock.packages[pkgKey].integrity = integrity;

          if (lock.dependencies && lock.dependencies['@chemisttasker/shared-core']) {
            lock.dependencies['@chemisttasker/shared-core'].integrity = integrity;
          }

          fs.writeFileSync(lockPath, JSON.stringify(lock, null, 2) + '\n', 'utf8');

          console.log('Patched @chemisttasker/shared-core integrity to:', integrity);
          console.log('Tarball:', tgzPath, 'bytes:', buf.length);
          NODE

      - name: Clean npm cache
        run: npm cache clean --force

      # -------------------------
      # OIDC token (keep your original approach intact)
      # -------------------------
      - name: Install OIDC Client from Core Package
        run: npm install @actions/core@1.6.0 @actions/http-client

      - name: Get Id Token
        uses: actions/github-script@v6
        id: idtoken
        with:
          script: |
            const coredemo = require('@actions/core')
            return await coredemo.getIDToken()
          result-encoding: string

      # -------------------------
      # Deploy (Option A):
      # Let Azure Static Web Apps build the app (so VITE_* env vars are applied at build time)
      # -------------------------
      - name: Build And Deploy
        id: builddeploy
        uses: Azure/static-web-apps-deploy@v1
        env:
          VITE_API_URL: ${{ secrets.VITE_API_URL }}
          VITE_RECAPTCHA_SITE_KEY: ${{ secrets.VITE_RECAPTCHA_SITE_KEY }}
          VITE_Maps_API_KEY: ${{ secrets.VITE_Maps_API_KEY }}
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_THANKFUL_STONE_0DAC7BA00 }}
          action: "upload"

          # Back to your original behaviour:
          app_location: "./frontend_web"
          api_location: ""
          output_location: "dist"

          github_id_token: ${{ steps.idtoken.outputs.result }}

          # Optional: stop source maps bloating your upload (keeps under SWA size limit)
          # If you *want* source maps, delete this line.
          app_build_command: "npm run build && find dist -type f -name '*.map' -delete"

  close_pull_request_job:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request Job
    steps:
      - name: Close Pull Request
        id: closepullrequest
        uses: Azure/static-web-apps-deploy@v1
        with:
          action: "close"
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_THANKFUL_STONE_0DAC7BA00 }}
